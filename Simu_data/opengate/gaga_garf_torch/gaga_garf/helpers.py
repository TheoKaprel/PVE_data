#!/usr/bin/env python3
import torch
import scipy
import numpy as np


def project_on_plane_torch(x, plane, image_plane_size_mm):
    """
    Project the x points (Ekine X Y Z dX dY dZ)
    on the image plane defined by plane_U, plane_V, plane_center, plane_normal
    """
    # n is the normal plane, duplicated n times


    n = plane["plane_normal"]

    # c0 is the center of the plane, duplicated n times
    c0 = plane["plane_center"]

    # r is the rotation matrix of the plane, according to the current rotation angle (around Y)

    # p is the set of points position generated by the GAN
    p = x[:, 1:4]

    # u is the set of points direction generated by the GAN
    u = x[:, 4:7]

    # w is the set of vectors from all points to the plane center
    w = p - c0

    # dot product between normal plane (n) and direction (u)
    ndotu = (n * u).sum(-1)

    # dot product between normal plane and vector from plane to point (w)
    si = (-(n * w).sum(-1) / ndotu)

    # only positive (direction to the plane)
    mask = si > 0
    mu = u[mask]
    mx = x[mask]
    mp = p[mask]
    msi = si[mask]

    # si is a (nb) size vector, expand it to (nb x 3)
    msi = msi.expand((3,len(msi))).T
    # intersection between point-direction and plane
    psip = mp + msi * mu + c0

    # apply the inverse of the rotation
    # psip = torch.from_numpy(r.apply(psi))

    # remove out of plane (needed ??)
    sizex = image_plane_size_mm[0] / 2.0
    sizey = image_plane_size_mm[1] / 2.0
    mask1 = psip[:, 0] < sizex
    mask2 = psip[:, 0] > -sizex
    mask3 = psip[:, 1] < sizey
    mask4 = psip[:, 1] > -sizey
    m = mask1 & mask2 & mask3 & mask4
    psip = psip[m]
    mu = mu[m]
    mx = mx[m]
    nb = len(psip)

    # reshape results
    pu = psip[:, 0].reshape((nb, 1))  # u
    pv = psip[:, 1].reshape((nb, 1))  # v
    # y = np.concatenate((pu, pv), axis=1)

    # rotate direction according to the plane
    # mup = torch.from_numpy(r.apply(mu))
    norm = torch.norm(mu, dim=1, keepdim=True)
    mup = mu / norm
    dx = mup[:, 0]
    dy = mup[:, 1]

    # concat the E
    E = mx[:, 0].reshape((nb, 1))
    dx = dx.reshape((nb, 1))
    dy = dy.reshape((nb, 1))
    data = torch.cat((pu,pv,dx,dy,E),dim=1)

    return data


def recons_ideal(output_fn, particles):
    c = scipy.constants.speed_of_light * 1000  # in mm
    positions,directions,times, energies = particles[:,1:4],particles[:,4:7],particles[:,7:8],particles[:,0:1]
    emissions = np.zeros_like(positions)
    for pos, dir, t, E, p in zip(positions, directions, times, energies, emissions):
        l = t * c
        p += pos + l * -dir

    size = np.array((256, 256, 256)).astype(int)
    spacing = np.array([2, 2, 2])
    offset = -size * spacing / 2.0 + spacing / 2.0
    print(f"Image size, spacing, offset: {size} {spacing} {offset}")
    pix = np.rint((positions - offset) / spacing).astype(int)

    # remove values out of the image fov
    print(f"Number of events after E selection: {len(pix)}")
    for i in [0, 1, 2]:
        pix = pix[(pix[:, i] < size[i]) & (pix[:, i] > 0)]
    print(f"Number of events in the image FOV:  {len(pix)}")


    print(f"Output file: {output_fn}")

    # create the image
    a = np.zeros(size)
    for x in pix:
        a[x[0], x[1], x[2]] += 1
    img = itk.image_from_array(a)
    #
    img.SetSpacing(spacing.tolist())
    img.SetOrigin(offset)
    itk.imwrite(img, output_fn)
